/* eslint-disable no-use-before-define */
/* eslint-disable max-classes-per-file */
import { ApiRx } from '@polkadot/api';
import { ApiTypes, AugmentedEvent, SubmittableExtrinsic } from '@polkadot/api/types';
import { Vec } from '@polkadot/types';
import { SpRuntimeDispatchError } from '@polkadot/types/lookup';
import { AnyTuple, Codec, IEvent, ISubmittableResult } from '@polkadot/types/types';
import { firstValueFrom, filter, map, pipe, tap } from 'rxjs';
import { DispatchError, Event, SignedBlock } from '@polkadot/types/interfaces';
import { IsEvent } from '@polkadot/types/metadata/decorate/types';
import { ItemizedStoragePageResponse, MessageSourceId, PageHash, PageId, PaginatedStorageResponse, SchemaId } from '@frequency-chain/api-augment/interfaces';
import type { Call } from '@polkadot/types/interfaces/runtime';
import { KeyringPair } from '@polkadot/keyring/types';
import { connect } from './apiConnection';

export type ItemizedSignaturePayload = {
  msaId?: MessageSourceId;
  schemaId?: SchemaId;
  targetHash?: PageHash;
  expiration?: number;
  actions?: any;
};
export type PaginatedUpsertSignaturePayload = {
  msaId?: MessageSourceId;
  schemaId?: SchemaId;
  pageId?: PageId;
  targetHash?: PageHash;
  expiration?: number;
  payload?: any;
};
export type PaginatedDeleteSignaturePayload = {
  msaId?: MessageSourceId;
  schemaId?: SchemaId;
  pageId?: PageId;
  targetHash?: PageHash;
  expiration?: any;
};

export class EventError extends Error {
  name: string = '';

  message: string = '';

  stack?: string = '';

  section?: string = '';

  rawError: DispatchError | SpRuntimeDispatchError;

  constructor(source: DispatchError | SpRuntimeDispatchError) {
    super();

    if (source.isModule) {
      const decoded = source.registry.findMetaError(source.asModule);
      this.name = decoded.name;
      this.message = decoded.docs.join(' ');
      this.section = decoded.section;
    } else {
      this.name = source.type;
      this.message = source.type;
      this.section = '';
    }
    this.rawError = source;
  }

  public toString() {
    return `${this.section}.${this.name}: ${this.message}`;
  }
}

export type EventMap = { [key: string]: Event };

function eventKey(event: Event): string {
  return `${event.section}.${event.method}`;
}

/**
 * These helpers return a map of events, some of which contain useful data, some of which don't.
 * Extrinsics that "create" records typically contain an ID of the entity they created, and this
 * would be a useful value to return. However, this data seems to be nested inside an array of arrays.
 *
 * Ex: schemaId = events["schemas.SchemaCreated"][<arbitrary_index>]
 *
 * To get the value associated with an event key, we would need to query inside that nested array with
 * a set of arbitrary indices. Should an object at any level of that querying be undefined, the helper
 * will throw an unchecked exception.
 *
 * To get type checking and cast a returned event as a specific event type, you can utilize TypeScripts
 * type guard functionality like so:
 *
 *      const msaCreatedEvent = events.defaultEvent;
 *      if (this.api.events.msa.MsaCreated.is(msaCreatedEvent)) {
 *          msaId = msaCreatedEvent.data.msaId;
 *      }
 *
 * Normally, I'd say the best experience is for the helper to return both the ID of the created entity
 * along with a map of emitted events. But in this case, returning that value will increase the complexity
 * of each helper, since each would have to check for undefined values at every lookup. So, this may be
 * a rare case when it is best to simply return the map of emitted events and trust the user to look them
 * up in the test.
 */

type ParsedEvent<C extends Codec[] = Codec[], N = unknown> = IEvent<C, N>;
// export type ParsedEventResult<C extends Codec[] = Codec[], N = unknown> = [ParsedEvent<C, N> | undefined, EventMap];
export type ParsedEventResult = [any, EventMap];

export class Extrinsic<T extends ISubmittableResult = ISubmittableResult, C extends Codec[] = Codec[], N = unknown> {
  private event?: IsEvent<C, N>;

  private extrinsic: () => SubmittableExtrinsic<'rxjs', T>;

  // private call: Call;
  private keys: KeyringPair;

  public api: ApiRx;

  constructor(extrinsic: () => SubmittableExtrinsic<'rxjs', T>, keys: KeyringPair, targetEvent?: IsEvent<C, N>) {
    this.extrinsic = extrinsic;
    this.keys = keys;
    this.event = targetEvent;
    this.api = this.api;
  }

  public get targetEvent() {
    return this.event;
  }

  public signAndSend(nonce?: number): Promise<ParsedEventResult> {
    return firstValueFrom(
      this.extrinsic()
        .signAndSend(this.keys, { nonce })
        .pipe(
          filter(({ status }) => status.isInBlock || status.isFinalized),
          this.parseResult(this.event),
        ),
    );
  }

  public payWithCapacity(nonce?: number): Promise<ParsedEventResult> {
    return firstValueFrom(
      this.api.tx.frequencyTxPayment
        .payWithCapacity(this.extrinsic())
        .signAndSend(this.keys, { nonce })
        .pipe(
          filter(({ status }) => status.isInBlock || status.isFinalized),
          this.parseResult(this.event),
        ),
    );
  }

  public getCall(): Call {
    const call = this.api.createType('Call', this.extrinsic.call);
    return call;
  }

  // eslint-disable-next-line no-shadow
  private parseResult<ApiType extends ApiTypes = 'rxjs', T extends AnyTuple = AnyTuple, N = unknown>(targetEvent?: AugmentedEvent<ApiType, T, N>) {
    return pipe(
      tap((result: ISubmittableResult) => {
        if (result.dispatchError) {
          const err = new EventError(result.dispatchError);
          log.err(err.toString());
          throw err;
        }
      }),
      map((result: ISubmittableResult) =>
        result.events.reduce((acc, { event }) => {
          acc[eventKey(event)] = event;
          if (targetEvent && targetEvent.is(event)) {
            acc.defaultEvent = event;
          }
          if (this.api.events.sudo.Sudid.is(event)) {
            const { sudoResult } = event.data;
            if (sudoResult.isErr) {
              const err = new EventError(sudoResult.asErr);
              log.err(err.toString());
              throw err;
            }
          }
          return acc;
        }, {} as EventMap),
      ),
      map((em) => {
        // const result: ParsedEventResult<T, N> = [undefined, {}];
        const result: ParsedEventResult = [undefined, {}];
        if (targetEvent && targetEvent.is(em?.defaultEvent)) {
          result[0] = em.defaultEvent;
        }
        result[1] = em;
        return result;
      }),
      // tap((events) => log(events)),
    );
  }
}

export class ExtrinsicHelper {
  public api: ApiRx;

  public async initialize(providerUrl?: string | string[] | undefined) {
    this.api = await connect(providerUrl);
  }

  public static async disconnect(): Promise<void> {
    await this.api.disconnect();
  }

  public static getLastBlock(): Promise<SignedBlock> {
    return firstValueFrom(this.api.rpc.chain.getBlock());
  }

  /** Stateful Storage Extrinsics */
  public static applyItemActions(keys: KeyringPair, schemaId: any, msa_id: MessageSourceId, actions: any, target_hash: any): Extrinsic {
    return new Extrinsic(() => this.api.tx.statefulStorage.applyItemActions(msa_id, schemaId, target_hash, actions), keys, this.api.events.statefulStorage.ItemizedPageUpdated);
  }

  public static removePage(keys: KeyringPair, schemaId: any, msa_id: MessageSourceId, page_id: any, target_hash: any): Extrinsic {
    return new Extrinsic(() => this.api.tx.statefulStorage.deletePage(msa_id, schemaId, page_id, target_hash), keys, this.api.events.statefulStorage.PaginatedPageDeleted);
  }

  public static upsertPage(keys: KeyringPair, schemaId: any, msa_id: MessageSourceId, page_id: any, payload: any, target_hash: any): Extrinsic {
    return new Extrinsic(() => this.api.tx.statefulStorage.upsertPage(msa_id, schemaId, page_id, target_hash, payload), keys, this.api.events.statefulStorage.PaginatedPageUpdated);
  }

  public static getItemizedStorage(msa_id: MessageSourceId, schemaId: any): Promise<ItemizedStoragePageResponse> {
    return firstValueFrom(this.api.rpc.statefulStorage.getItemizedStorage(msa_id, schemaId));
  }

  public static getPaginatedStorage(msa_id: MessageSourceId, schemaId: any): Promise<Vec<PaginatedStorageResponse>> {
    return firstValueFrom(this.api.rpc.statefulStorage.getPaginatedStorage(msa_id, schemaId));
  }

  public payWithCapacityBatchAll(keys: KeyringPair, calls: any): Extrinsic {
    return new Extrinsic(() => this.api.tx.frequencyTxPayment.payWithCapacityBatchAll(calls), keys, this.api.events.utility.BatchCompleted);
  }
}
